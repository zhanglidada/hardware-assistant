

<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="robots" content="noindex,nofollow,noarchive">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="format-detection" content="telephone=no">

	
		<title>GPU Database | TechPowerUp</title>
		

	
		<meta name="description" content="Graphics card and GPU database with specifications for products launched in recent years. Includes clocks, photos, and technical details.">
		

	
		
		<meta property="og:site_name" content="TechPowerUp">
		
		<meta property="og:title" content="TechPowerUp">
		
		<meta property="og:type" content="website">
		
		<meta property="og:image" content="https://tpucdn.com/images/logo_og-v1768462076.png">
		
		

	
		
		

	<style>
		:root {
			--bg: #f6f7fb;
			--card: #ffffff;
			--text: #111827;
			--muted: #6b7280;
			--border: #ccc;
		}

		* {
			box-sizing: border-box;
		}

		/* mobile-first */
		body {
			margin: 0;
			min-height: 100svh;
			display: flex;
			justify-content: center;
			align-items: flex-start;
			padding: 10vh 1rem 2rem;
			background: var(--bg);
			color: var(--text);
			font: 16px/1.6 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
		}

		.card {
			width: 100%;
			max-width: 720px;
			background: var(--card);
			border: 1px solid var(--border);
			border-radius: 4px;
			padding: 24px;
			box-shadow: 0 12px 28px rgba(0,0,0,.07);
		}

		h1 {
			margin: 0 0 .5rem;
			font-size: 1.6rem;
			line-height: 1.25;
		}

		p {
			margin: 0 0 .75rem;
		}

		/* bigger, clearer message */
		.lead {
			font-size: 1.1875rem; /* ~19px */
			line-height: 1.55;
			font-weight: 600;
		}

		.muted {
			color: var(--muted);
		}

		/* meta list: mobile stacked, slightly smaller text */
		dl.meta {
			margin: .75rem 0 0;
			display: grid;
			grid-template-columns: 1fr; /* mobile: stack */
			row-gap: .25rem;
			column-gap: .75rem;
			word-break: break-word;
			font-size: .9rem; /* smaller than body */
			color: var(--muted); /* deemphasize */
		}

			dl.meta dt {
				font-weight: 600;
				margin-top: .5rem;
			}

				dl.meta dt:first-child {
					margin-top: 0;
				}

			dl.meta dd {
				margin: 0;
				font-weight: 400;
				font-variant-numeric: tabular-nums;
			}

		footer {
			margin-top: 1.25rem;
			font-size: .875rem;
			color: var(--muted);
		}

			footer a {
				color: inherit;
				text-decoration: underline;
			}

				footer a:hover {
					color: var(--text);
				}

		/* wider viewports: inline two-column meta grid */
		@media (min-width: 640px) {
			dl.meta {
				grid-template-columns: auto 1fr;
			}

				dl.meta dt {
					margin-top: 0;
				}

				dl.meta dd {
					margin-left: .25rem;
				}

			.card {
				padding: 28px;
			}

			h1 {
				font-size: 1.75rem;
			}
		}
	</style>
</head>
<body>
	<main class="card" role="main" aria-labelledby="err-title">
		<h1 id="err-title">Automated bot check in progress</h1>

		
		
		<noscript>
		    <div style="color: red">Your browser must support Javascript</div>
		</noscript>
		
		<!-- Progress bar -->
		<div style="margin: 16px 0">
		    <div style="height: 12px; background: #e5e7eb; border-radius: 9999px; overflow: hidden">
		        <div id="pow-progress-bar" style="height: 100%; width: 0%; background: #16a34a; transition: width 1.0s ease-out"></div>
		    </div>
		</div>
		
		<p>
		    This should only take a few seconds. If you have issues, please do contact us, we want to learn about any problems.
		</p>
		
		<script>
		  /* -------------------- small helpers -------------------- */
		  function safe(fn, fallback) {
		    try {
		      return fn();
		    } catch (e) {
		      return fallback === undefined ? null : fallback;
		    }
		  }
		  async function safeAsync(fn, fallback) {
		    try {
		      return await fn();
		    } catch (e) {
		      return fallback === undefined ? null : fallback;
		    }
		  }
		
		  var lastMousePosition = {
		    clientX: null,
		    clientY: null,
		    pageX: null,
		    pageY: null,
		    screenX: null,
		    screenY: null
		  };
		
		  window.addEventListener("mousemove", function (e) {
		    lastMousePosition = {
		      clientX: e.clientX,
		      clientY: e.clientY,
		      pageX: e.pageX,
		      pageY: e.pageY,
		      screenX: e.screenX,
		      screenY: e.screenY
		    };
		  }, { passive: true });
		
		  /* -------------------- JS error logging -------------------- */
		
		  function logJsError(payload) {
		    try {
		      if (!JS_ERROR_ENDPOINT) return;
		
		      var body = JSON.stringify({
		        token: "8DDB06199C7AAB7A",
		        pageUrl: safe(function () { return location.href; }),
		        userAgent: safe(function () { return navigator.userAgent; }),
		        time: new Date().toISOString(),
		        payload: payload
		      });
		
		      // Prefer sendBeacon so errors are still sent on unload
		      if (navigator.sendBeacon) {
		        var blob = new Blob([body], { type: "application/json" });
		          navigator.sendBeacon("/.firewall/log-error", blob);
		        return;
		      }
		
		      // Fallback to fetch
		      fetch("/.firewall/log-error", {
		        method: "POST",
		        headers: { "Content-Type": "application/json" },
		        body: body,
		        keepalive: true
		      }).catch(function () { });
		    } catch (e) {
		      // swallow logging errors
		    }
		  }
		
		  // Synchronous JS errors, resource loading errors, etc.
		  window.addEventListener("error", function (event) {
		    try {
		      // Avoid logging our own logging errors recursively
		      if (event && event.filename && event.filename.indexOf("js-error") !== -1) return;
		
		      logJsError({
		        type: "error",
		        message: event && event.message,
		        filename: event && event.filename,
		        lineno: event && event.lineno,
		        colno: event && event.colno,
		        stack: event && event.error && event.error.stack ? event.error.stack : null
		      });
		    } catch (e) {
		      // ignore
		    }
		  });
		
		  // Unhandled promise rejections
		  window.addEventListener("unhandledrejection", function (event) {
		    try {
		      var reason = event && event.reason;
		      var message = null;
		      var stack = null;
		
		      if (reason && typeof reason === "object") {
		        message = reason.message || String(reason);
		        stack = reason.stack || null;
		      } else if (reason != null) {
		        message = String(reason);
		      }
		
		      logJsError({
		        type: "unhandledrejection",
		        message: message,
		        stack: stack
		      });
		    } catch (e) {
		      // ignore
		    }
		  });
		
		  function summarizeTimings(samples) {
		    if (!samples || !samples.length) return null;
		    var min = samples[0];
		    var max = samples[0];
		    var sum = 0;
		    for (var i = 0; i < samples.length; i++) {
		      var v = samples[i];
		      if (v < min) min = v;
		      if (v > max) max = v;
		      sum += v;
		    }
		    var avg = sum / samples.length;
		    return {
		      count: samples.length,
		      min: min,
		      max: max,
		      avg: avg
		    };
		  }
		
		  function setProgress(percent) {
		    try {
		      var bar = document.getElementById("pow-progress-bar");
		      if (!bar) return;
		      if (percent < 0) percent = 0;
		      if (percent > 100) percent = 100;
		      bar.style.width = percent + "%";
		    } catch (e) {
		      // ignore
		    }
		  }
		
		  /* -------------------- probes -------------------- */
		  function getConnectionInfo() {
		    try {
		      var c =
		        navigator.connection ||
		        navigator.mozConnection ||
		        navigator.webkitConnection;
		      if (!c) return null;
		      return {
		        effectiveType: "effectiveType" in c ? c.effectiveType : null,
		        downlink: typeof c.downlink === "number" ? c.downlink : null,
		        downlinkMax: typeof c.downlinkMax === "number" ? c.downlinkMax : null,
		        rtt: typeof c.rtt === "number" ? c.rtt : null,
		        saveData: typeof c.saveData === "boolean" ? c.saveData : null,
		        type: "type" in c ? c.type : null
		      };
		    } catch (e) {
		      return null;
		    }
		  }
		
		  function getTouchInfo() {
		    var max =
		      typeof navigator.maxTouchPoints === "number"
		        ? navigator.maxTouchPoints
		        : null;
		    var msMax =
		      typeof navigator.msMaxTouchPoints === "number"
		        ? navigator.msMaxTouchPoints
		        : null;
		    var hasOnTouchStart =
		      "ontouchstart" in window || "ontouchstart" in document.documentElement;
		    return {
		      maxTouchPoints: max,
		      msMaxTouchPoints: msMax,
		      hasOnTouchStart: hasOnTouchStart,
		      isLikelyTouchDevice: !!(max > 0 || msMax > 0 || hasOnTouchStart)
		    };
		  }
		
		  function getWindowScreen() {
		    var screenWidth = safe(function () { return screen.width; });
		    var screenHeight = safe(function () { return screen.height; });
		    var screenAvailWidth = safe(function () { return screen.availWidth; });
		    var screenAvailHeight = safe(function () { return screen.availHeight; });
		    var colorDepth = safe(function () { return screen.colorDepth; });
		    var pixelDepth = safe(function () { return screen.pixelDepth; });
		
		    var innerWidth = safe(function () { return window.innerWidth; });
		    var innerHeight = safe(function () { return window.innerHeight; });
		    var outerWidth = safe(function () { return window.outerWidth; });
		    var outerHeight = safe(function () { return window.outerHeight; });
		    var screenXPos = safe(function () { return window.screenX ?? window.screenLeft; });
		    var screenYPos = safe(function () { return window.screenY ?? window.screenTop; });
		    var dpr = safe(function () { return window.devicePixelRatio; });
		
		    var frameHorizontal = outerWidth != null && innerWidth != null ? outerWidth - innerWidth : null;
		    var frameVertical = outerHeight != null && innerHeight != null ? outerHeight - innerHeight : null;
		
		    return {
		      screen: {
		        width: screenWidth,
		        height: screenHeight,
		        availWidth: screenAvailWidth,
		        availHeight: screenAvailHeight,
		        colorDepth: colorDepth,
		        pixelDepth: pixelDepth
		      },
		      window: {
		        innerWidth: innerWidth,
		        innerHeight: innerHeight,
		        outerWidth: outerWidth,
		        outerHeight: outerHeight,
		        screenX: screenXPos,
		        screenY: screenYPos,
		        devicePixelRatio: dpr
		      },
		      frame: {
		        horizontal: frameHorizontal,
		        vertical: frameVertical
		      },
		      media: {
		        colorGamut:
		          ["srgb", "p3", "rec2020"].find(function (g) {
		            return safe(function () {
		              return matchMedia("(color-gamut:" + g + ")").matches;
		            }, false);
		          }) || null,
		        darkMode: safe(function () {
		          return matchMedia("(prefers-color-scheme: dark)").matches;
		        }),
		        reducedMotion: safe(function () {
		          return matchMedia("(prefers-reduced-motion: reduce)").matches;
		        })
		      }
		    };
		  }
		
		  function getLocaleInfo() {
		    return {
		      language: safe(function () { return navigator.language; }),
		      languages: safe(function () { return navigator.languages; }),
		      time: {
		        timeZone: safe(function () {
		          return Intl.DateTimeFormat().resolvedOptions().timeZone;
		        }),
		        timezoneOffsetMinutes: safe(function () {
		          return new Date().getTimezoneOffset();
		        }),
		        nowIso: new Date().toISOString()
		      }
		    };
		  }
		
		  function getNavigatorBasics() {
		    var uad = navigator.userAgentData || null;
		    return {
		      userAgent: safe(function () { return navigator.userAgent; }),
		      platform: safe(function () { return navigator.platform; }),
		      oscpu: safe(function () { return navigator.oscpu; }),
		      buildId: safe(function () { return navigator.buildID; }),
		      pdfViewerEnabled: safe(function () { return navigator.pdfViewerEnabled; }),
		      webdriver: safe(function () { return navigator.webdriver; }),
		      hardwareConcurrency: safe(function () {
		        return navigator.hardwareConcurrency;
		      }),
		      deviceMemory: safe(function () { return navigator.deviceMemory; }),
		      uaCh: uad
		        ? {
		            mobile: safe(function () { return uad.mobile; }),
		            brands: safe(function () { return uad.brands; }),
		            highEntropy: null
		          }
		        : null
		    };
		  }
		
		  async function getHighEntropyUA() {
		    try {
		      if (!navigator.userAgentData || !navigator.userAgentData.getHighEntropyValues) return null;
		      return await navigator.userAgentData.getHighEntropyValues([
		        "architecture",
		        "bitness",
		        "model",
		        "platform",
		        "platformVersion",
		        "uaFullVersion",
		        "fullVersionList"
		      ]);
		    } catch (e) {
		      return null;
		    }
		  }
		
		  function getPluginsInfo() {
		    function toArr(list) {
		      try {
		        return Array.from(list || []).map(function (p) {
		          return {
		            name: p.name,
		            filename: p.filename,
		            description: p.description
		          };
		        });
		      } catch (e) {
		        return null;
		      }
		    }
		    return {
		      plugins: toArr(navigator.plugins),
		      mimeTypes: toArr(navigator.mimeTypes)
		    };
		  }
		
		  async function getPermissionsSnapshot() {
		    var names = [
		      "geolocation",
		      "notifications",
		      "camera",
		      "microphone",
		      "clipboard-read",
		      "clipboard-write"
		    ];
		    var out = {};
		    if (!navigator.permissions || !navigator.permissions.query) return null;
		    for (var i = 0; i < names.length; i++) {
		      var name = names[i];
		      out[name] = await safeAsync(async function () {
		        var res = await navigator.permissions.query({ name: name });
		        return res && res.state ? res.state : null;
		      }, null);
		    }
		    return out;
		  }
		
		  function getWebGLInfo() {
		    try {
		      var canvas = document.createElement("canvas");
		      var gl =
		        canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
		      if (!gl) return { supported: false };
		      var info = {
		        supported: true,
		        antialias: !!(gl.getContextAttributes() && gl.getContextAttributes().antialias)
		      };
		      var ext = gl.getExtension("WEBGL_debug_renderer_info");
		      info.vendor = ext
		        ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL)
		        : gl.getParameter(gl.VENDOR);
		      info.renderer = ext
		        ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL)
		        : gl.getParameter(gl.RENDERER);
		      info.version = gl.getParameter(gl.VERSION);
		      info.shadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
		      info.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
		      return info;
		    } catch (e) {
		      return { supported: false };
		    }
		  }
		
		  async function getWebGPUInfo() {
		    try {
		      if (!("gpu" in navigator) || !navigator.gpu) {
		        return { supported: false };
		      }
		
		      var info = { supported: true, adapterAvailable: false };
		
		      var adapter = await navigator.gpu.requestAdapter();
		      if (!adapter) {
		        return info;
		      }
		
		      info.adapterAvailable = true;
		      info.adapter = {
		        name: adapter.name || null,
		        isFallbackAdapter: !!adapter.isFallbackAdapter
		      };
		
		      if (adapter.limits) {
		        info.limits = {
		          maxTextureDimension1D: adapter.limits.maxTextureDimension1D,
		          maxTextureDimension2D: adapter.limits.maxTextureDimension2D,
		          maxTextureDimension3D: adapter.limits.maxTextureDimension3D,
		          maxBindGroups: adapter.limits.maxBindGroups,
		          maxDynamicUniformBuffersPerPipelineLayout: adapter.limits.maxDynamicUniformBuffersPerPipelineLayout,
		          maxDynamicStorageBuffersPerPipelineLayout: adapter.limits.maxDynamicStorageBuffersPerPipelineLayout,
		          maxSampledTexturesPerShaderStage: adapter.limits.maxSampledTexturesPerShaderStage,
		          maxSamplersPerShaderStage: adapter.limits.maxSamplersPerShaderStage,
		          maxStorageBuffersPerShaderStage: adapter.limits.maxStorageBuffersPerShaderStage,
		          maxStorageTexturesPerShaderStage: adapter.limits.maxStorageTexturesPerShaderStage,
		          maxUniformBuffersPerShaderStage: adapter.limits.maxUniformBuffersPerShaderStage,
		          maxBufferSize: adapter.limits.maxBufferSize
		        };
		      } else {
		        info.limits = null;
		      }
		
		      if (adapter.features && adapter.features.forEach) {
		        var features = [];
		        adapter.features.forEach(function (f) { features.push(f); });
		        info.features = features;
		      } else {
		        info.features = null;
		      }
		
		      return info;
		    } catch (e) {
		      return {
		        supported: false,
		        error: {
		          message: e && e.message ? e.message : String(e),
		          name: e && e.name ? e.name : null
		        }
		      };
		    }
		  }
		
		  async function getAudioProbe() {
		    try {
		      var Ctx = window.OfflineAudioContext || window.webkitOfflineAudioContext;
		      if (!Ctx) return { supported: false, rendered: false };
		      var ctx = new Ctx(1, 44100, 44100);
		      var osc = ctx.createOscillator();
		      var comp = ctx.createDynamicsCompressor();
		      osc.connect(comp);
		      comp.connect(ctx.destination);
		      osc.start(0);
		      await ctx.startRendering();
		      return { supported: true, rendered: true };
		    } catch {
		      return {
		        supported: !!(window.OfflineAudioContext || window.webkitOfflineAudioContext),
		        rendered: false
		      };
		    }
		  }
		
		  async function getStorageEstimate() {
		    try {
		      if (!navigator.storage || !navigator.storage.estimate) return null;
		      var est = await navigator.storage.estimate();
		      return {
		        quota: typeof est.quota === "number"
		          ? Math.round((est.quota / (1024 * 1024)) * 10) / 10
		          : null,
		        usage: typeof est.usage === "number"
		          ? Math.round((est.usage / (1024 * 1024)) * 10) / 10
		          : null,
		        usageDetails: est.usageDetails || null,
		        persisted:
		          typeof navigator.storage.persisted === "function"
		            ? await navigator.storage.persisted()
		            : null
		      };
		    } catch {
		      return null;
		    }
		  }
		
		  async function getRTCIPs() {
		    try {
		      var pc = new RTCPeerConnection({ iceServers: [] });
		      var ips = new Set();
		      pc.createDataChannel("x");
		      var offer = await pc.createOffer();
		      await pc.setLocalDescription(offer);
		      return await new Promise(function (resolve) {
		        var done = false;
		        function finish() {
		          if (!done) {
		            done = true;
		            pc.close();
		            resolve(Array.from(ips));
		          }
		        }
		        var timeout = setTimeout(finish, 1000);
		        pc.onicecandidate = function (e) {
		          if (!e || !e.candidate) {
		            clearTimeout(timeout);
		            finish();
		            return;
		          }
		          var m =
		            e.candidate.candidate &&
		            e.candidate.candidate.match(
		              /(?:\d{1,3}\.){3}\d{1,3}|\[[a-fA-F0-9:]+\]/
		            );
		          if (m) ips.add(m[0]);
		        };
		      });
		    } catch {
		      return null;
		    }
		  }
		
		  async function getBattery() {
		    try {
		      if (!navigator.getBattery) return null;
		      var b = await navigator.getBattery();
		      return {
		        charging: b.charging,
		        level: b.level,
		        chargingTime: b.chargingTime,
		        dischargingTime: b.dischargingTime
		      };
		    } catch {
		      return null;
		    }
		  }
		
		  function getChromeObject() {
		    return {
		      hasChromeObject: "chrome" in window,
		      hasChromeRuntime: safe(function () {
		        return !!(window.chrome && window.chrome.runtime);
		      }),
		      hasChromeApp: safe(function () {
		        return !!(window.chrome && window.chrome.app);
		      })
		    };
		  }
		
		  // -------- NEW: Playwright leak detection (bypassCSP, __pwInitScripts, exposeFunction) --------
		  function getPlaywrightLeaks() {
		    try {
		      var hasBypassCsp = !!safe(function () { return window.bypassCSP; });
		      var hasPwInitScripts = !!safe(function () { return window.__pwInitScripts; });
		
		      var exposeFunctionProps = [];
		      try {
		        var props = Object.getOwnPropertyNames(window);
		        for (var i = 0; i < props.length; i++) {
		          var name = props[i];
		
		          // obvious name leak
		          if (name.indexOf("exposeFunction") !== -1) {
		            exposeFunctionProps.push(name);
		            continue;
		          }
		
		          var val = null;
		          try {
		            val = window[name];
		          } catch (e) { }
		
		          if (typeof val === "function") {
		            var fnName = val.name || "";
		            if (fnName && fnName.toLowerCase().indexOf("exposefunction") !== -1) {
		              exposeFunctionProps.push(name);
		            }
		          }
		        }
		      } catch (e) { }
		
		      return {
		        hasBypassCsp: hasBypassCsp,
		        hasPwInitScripts: hasPwInitScripts,
		        exposeFunctionProps: exposeFunctionProps.length ? exposeFunctionProps : null
		      };
		    } catch (e) {
		      return null;
		    }
		  }
		  // -------- END NEW --------
		
		  async function getCookieStatus() {
		    var testName = "fp_cookie_test_" + Math.random().toString(36).slice(2);
		    var testValue = Date.now().toString();
		    try {
		      document.cookie = testName + "=" + testValue + "; path=/";
		      var readBack = document.cookie.indexOf(testName + "=" + testValue) !== -1;
		      var persistentAllowed = null;
		      try {
		        var expires = new Date(Date.now() + 60000).toUTCString();
		        document.cookie =
		          testName + "_p=" + testValue + "; expires=" + expires + "; path=/";
		        persistentAllowed =
		          document.cookie.indexOf(testName + "_p=" + testValue) !== -1;
		      } catch {
		        persistentAllowed = false;
		      }
		      document.cookie = testName + "=; Max-Age=0; path=/";
		      document.cookie = testName + "_p=; Max-Age=0; path=/";
		      return {
		        cookiesEnabled: navigator.cookieEnabled,
		        canSetSessionCookie: readBack,
		        canSetPersistentCookie: persistentAllowed
		      };
		    } catch {
		      return {
		        cookiesEnabled: navigator.cookieEnabled,
		        canSetSessionCookie: false,
		        canSetPersistentCookie: false
		      };
		    }
		  }
		
		  /* -------------------- DNS timing probe -------------------- */
		    async function timeRequest(url) {
		        var timeoutMs = 1500;
		        var start = performance.now();
		        var controller = null;
		        var timeoutId = null;
		
		        try {
		            if (typeof AbortController !== "undefined") {
		                controller = new AbortController();
		                timeoutId = setTimeout(function () {
		                    try { controller.abort(); } catch (e) { }
		                }, timeoutMs);
		            }
		
		            var opts = {
		                method: "GET",
		                mode: "no-cors",
		                cache: "no-store"
		            };
		            if (controller) opts.signal = controller.signal;
		
		            await fetch(url, opts);
		
		            return {
		                duration: performance.now() - start,
		                error: null
		            };
		        } catch (e) {
		            const aborted = controller && controller.signal && controller.signal.aborted;
		            const offline = typeof navigator !== "undefined" && navigator.onLine === false;
		
		            // ----- single state string -----
		            let state = "network-error";
		            if (offline) state = "offline";
		            else if (aborted) state = "timeout";
		            // --------------------------------
		
		            return {
		                duration: null,
		                error: {
		                    message: e && e.message ? e.message : String(e),
		                    name: e && e.name ? e.name : null,
		                    stack: e && e.stack ? e.stack : null,
		                    timestamp: Date.now(),
		                    state
		                }
		            };
		        } finally {
		            if (timeoutId != null) clearTimeout(timeoutId);
		        }
		    }
		
		  async function timeHost(url) {
		    var samples = 2;
		    var durations = [];
		    var errors = [];
		
		    for (var i = 0; i < samples; i++) {
		      var r = await timeRequest(url);
		      durations.push(r.duration);
		      if (r.error) errors.push(r.error);
		    }
		
		    var domain;
		    try { domain = new URL(url).hostname; }
		    catch { domain = url; }
		
		    var out = { durations: durations };
		    if (errors.length > 0) out.errors = errors;
		
		    return { domain: domain, data: out };
		  }
		
		  async function getDnsTiming() {
		    var urls = [
		      "https://www.google.com/favicon.ico",
		      "https://www.cloudflare.com/favicon.ico",
		      "https://www.wikipedia.org/favicon.ico",
		      "https://www.reddit.com/favicon.ico",
		      "https://www.amazon.com/favicon.ico",
		      "https://yandex.ru/favicon.ico",
		      "https://www.mercadolibre.com/favicon.ico",
		      "https://www.globo.com/favicon.ico",
		      "https://www.news24.com/favicon.ico",
		      "https://www.jumia.com.ng/favicon.ico",
		      "https://www.baidu.com/favicon.ico",
		      "https://www.aliexpress.com/favicon.ico",
		      "https://www.abc.net.au/favicon.ico"
		    ];
		
		    var promises = urls.map(function (url) {
		      return timeHost(url);
		    });
		
		    var raw = await Promise.all(promises);
		    var result = {};
		
		    for (var i = 0; i < raw.length; i++) {
		      result[raw[i].domain] = raw[i].data;
		    }
		
		    return result;
		  }
		
		  /* -------------------- Event loop timing probes -------------------- */
		  async function probeSetTimeoutZero(count) {
		    var samples = [];
		    for (var i = 0; i < count; i++) {
		      var t0 = performance.now();
		      await new Promise(function (resolve) {
		        setTimeout(function () {
		          var dt = performance.now() - t0;
		          samples.push(dt);
		          resolve();
		        }, 0);
		      });
		    }
		    return samples;
		  }
		
		  async function probePromiseThen(count) {
		    var samples = [];
		    for (var i = 0; i < count; i++) {
		      var t0 = performance.now();
		      await new Promise(function (resolve) {
		        Promise.resolve().then(function () {
		          var dt = performance.now() - t0;
		          samples.push(dt);
		          resolve();
		        });
		      });
		    }
		    return samples;
		  }
		
		  async function probeRaf(count) {
		    if (!window.requestAnimationFrame) {
		      return { supported: false, samples: null, summary: null };
		    }
		    var samples = [];
		    return await new Promise(function (resolve) {
		      var prev = null;
		      var n = 0;
		      function step(ts) {
		        if (prev != null) {
		          var diff = ts - prev;
		          samples.push(diff);
		          n++;
		          if (n >= count) {
		            resolve({
		              supported: true,
		              samples: samples,
		              summary: summarizeTimings(samples)
		            });
		            return;
		          }
		        }
		        prev = ts;
		        requestAnimationFrame(step);
		      }
		      requestAnimationFrame(step);
		    });
		  }
		
		  async function probeIdleCallback(timeoutMs) {
		    if (!window.requestIdleCallback) {
		      return {
		        supported: false,
		        fired: false,
		        timeoutMs: timeoutMs,
		        didTimeout: null,
		        timeToFireMs: null,
		        timeRemaining: null
		      };
		    }
		    var start = performance.now();
		    return await new Promise(function (resolve) {
		      var settled = false;
		      function finish(data) {
		        if (!settled) {
		          settled = true;
		          resolve(data);
		        }
		      }
		      var id = requestIdleCallback(function (deadline) {
		        var timeToFire = performance.now() - start;
		        finish({
		          supported: true,
		          fired: true,
		          timeoutMs: timeoutMs,
		          didTimeout: deadline && deadline.didTimeout === true,
		          timeToFireMs: timeToFire,
		          timeRemaining: deadline && typeof deadline.timeRemaining === "function"
		            ? deadline.timeRemaining()
		            : null
		        });
		      }, { timeout: timeoutMs });
		      setTimeout(function () {
		        if (settled) return;
		        cancelIdleCallback(id);
		        finish({
		          supported: true,
		          fired: false,
		          timeoutMs: timeoutMs,
		          didTimeout: true,
		          timeToFireMs: performance.now() - start,
		          timeRemaining: null
		        });
		      }, timeoutMs + 50);
		    });
		  }
		
		  async function getEventLoopTimings() {
		    var setTimeoutSamples = await probeSetTimeoutZero(16);
		    var promiseSamples = await probePromiseThen(16);
		    var rafResult = await probeRaf(16);
		    var idleResult = await probeIdleCallback(100);
		
		    return {
		      setTimeout0: {
		        samples: setTimeoutSamples,
		        summary: summarizeTimings(setTimeoutSamples)
		      },
		      promiseThen: {
		        samples: promiseSamples,
		        summary: summarizeTimings(promiseSamples)
		      },
		      requestAnimationFrame: rafResult,
		      idleCallback: idleResult
		    };
		  }
		
		  /* -------------------- CSS animation timing probe -------------------- */
		  async function getCssAnimationTimings() {
		    try {
		      var style = document.createElement("style");
		      style.type = "text/css";
		      var animName = "fpAnim_" + Math.random().toString(36).slice(2);
		      style.textContent =
		        "@keyframes " + animName + " { " +
		        "0% { opacity: 0; } " +
		        "100% { opacity: 1; } " +
		        "}" +
		        ".fp-anim-probe { " +
		        "position: absolute; left: -9999px; top: -9999px; " +
		        "width: 10px; height: 10px; " +
		        "animation: " + animName + " 120ms linear infinite; " +
		        "}";
		      document.head.appendChild(style);
		
		      var el = document.createElement("div");
		      el.className = "fp-anim-probe";
		      document.body.appendChild(el);
		
		      var samples = [];
		      var last = null;
		      var maxCount = 12;
		
		      return await new Promise(function (resolve) {
		        var settled = false;
		        function cleanup() {
		          try {
		            if (el && el.parentNode) el.parentNode.removeChild(el);
		            if (style && style.parentNode) style.parentNode.removeChild(style);
		          } catch (e) {}
		        }
		        function finish() {
		          if (settled) return;
		          settled = true;
		          cleanup();
		          resolve({
		            supported: true,
		            samples: samples,
		            summary: summarizeTimings(samples)
		          });
		        }
		
		        el.addEventListener("animationiteration", function () {
		          var now = performance.now();
		          if (last != null) {
		            samples.push(now - last);
		          }
		          last = now;
		          if (samples.length >= maxCount) {
		            finish();
		          }
		        });
		
		        // safety timeout
		        setTimeout(function () {
		          if (settled) return;
		          cleanup();
		          if (!samples.length) {
		            resolve({
		              supported: false,
		              samples: samples,
		              summary: summarizeTimings(samples)
		            });
		          } else {
		            finish();
		          }
		        }, 3000);
		      });
		    } catch (e) {
		      return {
		        supported: false,
		        samples: null,
		        summary: null
		      };
		    }
		  }
		
		  /* -------------------- assemble & send -------------------- */
		  async function buildData() {
		    setProgress(3);
		    var basics = getNavigatorBasics();
		    if (basics.uaCh) basics.uaCh.highEntropy = await getHighEntropyUA();
		    setProgress(10);
		
		    var connection = getConnectionInfo();
		    var touch = getTouchInfo();
		    var display = getWindowScreen();
		    var locale = getLocaleInfo();
		    setProgress(15);
		
		    var plugins = getPluginsInfo();
		    var permissions = await getPermissionsSnapshot();
		    var webgl = getWebGLInfo();
		    var webgpu = await getWebGPUInfo();
		    var audio = await getAudioProbe();
		    setProgress(30);
		
		    var storage = await getStorageEstimate();
		    setProgress(40);
		
		    var rtcIPs = await getRTCIPs();
		    var battery = await getBattery();
		    var chromeObj = getChromeObject();
		    var playwrightLeaks = getPlaywrightLeaks();
		    var cookies = await getCookieStatus();
		    setProgress(50);
		
		    var dnsTiming = await getDnsTiming();
		    setProgress(70);
		
		    var eventLoopTimings = await getEventLoopTimings();
		    setProgress(80);
		
		    var cssAnimationTimings = await getCssAnimationTimings();
		    setProgress(100);
		
		    return {
		      meta: {
		        page: {
		          url: safe(function () { return location.href; }),
		          referrer: safe(function () { return document.referrer; }),
		          visibilityState: safe(function () { return document.visibilityState; }),
		          wasHiddenAtLoad: safe(function () { return document.visibilityState === "hidden"; })
		        },
		        timing: {
		          nowEpochMs: Date.now(),
		          navStart: safe(function () {
		            return performance.timing && performance.timing.navigationStart;
		          })
		        }
		      },
		      navigator: basics,
		      connection: connection,
		      touch: touch,
		      display: display,
		      locale: locale,
		      plugins: plugins,
		      permissions: permissions,
		      webgl: webgl,
		      webgpu: webgpu,
		      audio: audio,
		      storage: storage,
		      rtcIPs: rtcIPs,
		      battery: battery,
		      chromeObj: chromeObj,
		      cookies: cookies,
		      playwrightLeaks: playwrightLeaks,
		      pointer: {
		        lastMousePosition: lastMousePosition
		      },
		      timingProbes: {
		        dnsTiming: dnsTiming,
		        eventLoop: eventLoopTimings,
		        cssAnimation: cssAnimationTimings
		      }
		    };
		  }
		
		  async function check() {
		    setProgress(1);
		    try {
		      var data = await buildData();
		      var payload = JSON.stringify({ token: "8DDB06199C7AAB7A", data: data });
		
		      var res = await fetch("/.firewall/verify", {
		        method: "POST",
		        headers: { "Content-Type": "application/json" },
		        body: payload
		      });
		
		      if (res.status === 200) {
		        window.location.replace("/.firewall/verify?token=8DDB06199C7AAB7A&redir=" + encodeURIComponent(window.location.href));
		        return;
		      }
		
		      var el = document.getElementById("err-title");
		      if (el) el.innerText = "Request failed (HTTP " + res.status + ")";
		    } catch (err) {
		      console.log(err);
		      var el2 = document.getElementById("err-title");
		      if (el2) el2.innerText = "Request Failed";
		
		      // Also report this error to the firewall
		      logJsError({
		        type: "check-exception",
		        message: err && err.message ? err.message : String(err),
		        stack: err && err.stack ? err.stack : null
		      });
		    }
		  }
		
		  check();
		</script>
		


		<footer>
			Need help? <a href="mailto:w1zzard@techpowerup.com">Contact Us</a>. Please mention your IP: 160.30.4.170
		</footer>
	</main>
</body>
</html>

